<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Neon Block Puzzle</title>
<style>
  :root {
    --bg1: #6a00ff;
    --bg2: #00b3ff;
    --bg3: #ff4fd8;
    --glass: rgba(255, 255, 255, 0.12);
    --glass-border: rgba(255, 255, 255, 0.2);
    --text: #f7f8ff;
    --accent: #00f7ff;
    --danger: #ff4f74;
  }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html, body {
    margin: 0; padding: 0; width: 100%; height: 100%;
    font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
    background: radial-gradient(circle at top left, var(--bg3), transparent 40%),
                radial-gradient(circle at bottom right, var(--bg2), transparent 40%),
                linear-gradient(135deg, #2b0f5b, #0b1b4f 70%);
    color: var(--text);
    overflow: hidden;
    touch-action: none;
  }
  #app {
    width: 100%; height: 100%;
    display: flex; align-items: center; justify-content: center;
  }
  .screen {
    position: absolute; inset: 0;
    display: flex; align-items: center; justify-content: center;
    transition: opacity 0.4s ease, transform 0.4s ease;
    pointer-events: none;
    opacity: 0;
    transform: scale(1.03);
  }
  .screen.active {
    opacity: 1; transform: scale(1);
    pointer-events: auto;
  }
  .panel {
    width: min(92vw, 640px);
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 24px;
    padding: 28px;
    backdrop-filter: blur(18px);
    box-shadow: 0 20px 60px rgba(5, 0, 30, 0.45), inset 0 0 40px rgba(255,255,255,0.08);
  }
  h1 {
    margin: 0 0 10px;
    font-size: 32px; letter-spacing: 1px;
    text-align: center;
    text-shadow: 0 0 14px rgba(0, 247, 255, 0.6);
  }
  .subtitle { text-align: center; opacity: 0.8; margin-bottom: 22px; }
  .menu-buttons { display: grid; gap: 14px; }
  .row { display: flex; gap: 12px; flex-wrap: wrap; }
  .btn {
    flex: 1;
    padding: 14px 16px;
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,0.2);
    background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
    color: var(--text);
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
    box-shadow: 0 8px 20px rgba(0,0,0,0.2);
  }
  .btn:hover { transform: translateY(-2px); box-shadow: 0 10px 22px rgba(0,0,0,0.3); }
  .btn:active { transform: translateY(1px) scale(0.99); }
  .btn.primary { background: linear-gradient(135deg, #5b2bff, #00d4ff); }
  .btn.alt { background: linear-gradient(135deg, #ff2b8a, #ff945b); }
  .btn.ghost { background: transparent; border: 1px solid rgba(255,255,255,0.3); }

  #game-ui {
    width: min(96vw, 980px);
    height: min(96vh, 900px);
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: 12px;
  }
  .hud {
    display: grid;
    grid-template-columns: repeat(3, minmax(0,1fr));
    gap: 12px;
  }
  .hud .tile {
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    padding: 10px 14px;
    text-align: center;
    box-shadow: inset 0 0 20px rgba(255,255,255,0.08);
  }
  .hud .label { font-size: 12px; opacity: 0.7; }
  .hud .value { font-size: 20px; font-weight: 700; }
  #canvas-wrap {
    position: relative;
    background: rgba(10, 5, 30, 0.6);
    border-radius: 24px;
    border: 1px solid rgba(255,255,255,0.15);
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,0.4);
  }
  canvas { display: block; width: 100%; height: 100%; }
  #tray {
    display: grid;
    grid-template-columns: repeat(3, minmax(0,1fr));
    gap: 12px;
  }
  .tray-item {
    background: var(--glass);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 18px;
    min-height: 110px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }
  .footer-controls {
    display: flex; justify-content: space-between; gap: 12px; align-items: center;
  }
  .pill {
    padding: 8px 12px; border-radius: 999px; font-size: 12px;
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.2);
  }
  .overlay {
    position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
    background: rgba(5, 0, 20, 0.5);
    backdrop-filter: blur(6px);
    opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
  }
  .overlay.active { opacity: 1; pointer-events: auto; }
  .popup {
    position: absolute; pointer-events: none; font-weight: 700; text-shadow: 0 0 10px rgba(0,0,0,0.5);
  }
  @media (max-width: 720px) {
    #game-ui { grid-template-rows: auto 1fr auto; }
    .hud { grid-template-columns: repeat(2, minmax(0,1fr)); }
    .hud .tile:last-child { grid-column: span 2; }
  }
</style>
</head>
<body>
<div id="app">
  <div id="start-screen" class="screen active">
    <div class="panel">
      <h1>Neon Block Puzzle</h1>
      <div class="subtitle">Classic 10x10 block puzzle with a neon twist</div>
      <div class="menu-buttons">
        <button class="btn primary" data-mode="endless">Endless Mode</button>
        <div class="row">
          <button class="btn alt" data-mode="clock" data-time="60">Clock Rush 1:00</button>
          <button class="btn alt" data-mode="clock" data-time="180">Clock Rush 3:00</button>
          <button class="btn alt" data-mode="clock" data-time="300">Clock Rush 5:00</button>
        </div>
        <div class="row">
          <button id="toggle-sound" class="btn ghost">Sound: On</button>
          <button id="toggle-music" class="btn ghost">Music: On</button>
        </div>
      </div>
    </div>
  </div>

  <div id="game-screen" class="screen">
    <div id="game-ui">
      <div class="hud">
        <div class="tile"><div class="label">Score</div><div id="score" class="value">0</div></div>
        <div class="tile"><div class="label">High Score</div><div id="high-score" class="value">0</div></div>
        <div class="tile"><div class="label">Timer</div><div id="timer" class="value">--:--</div></div>
      </div>
      <div id="canvas-wrap">
        <canvas id="game-canvas" aria-label="Block puzzle board"></canvas>
        <div id="pause-overlay" class="overlay">
          <div class="panel" style="width: min(90vw, 420px);">
            <h1>Paused</h1>
            <div class="menu-buttons">
              <button id="resume-btn" class="btn primary">Resume</button>
              <button id="restart-btn" class="btn ghost">Restart</button>
              <button id="exit-btn" class="btn ghost">Exit to Menu</button>
            </div>
          </div>
        </div>
        <div id="gameover-overlay" class="overlay">
          <div class="panel" style="width: min(90vw, 420px);">
            <h1>Game Over</h1>
            <div class="subtitle" id="final-score">Score: 0</div>
            <div class="subtitle" id="final-high">High Score: 0</div>
            <div class="menu-buttons">
              <button id="play-again" class="btn primary">Play Again</button>
              <button id="back-menu" class="btn ghost">Back to Menu</button>
            </div>
          </div>
        </div>
      </div>
      <div id="tray"></div>
      <div class="footer-controls">
        <button id="pause-btn" class="btn ghost">Pause</button>
        <span id="combo-pill" class="pill">Combo x1</span>
        <button id="sound-btn" class="btn ghost">Sound: On</button>
      </div>
    </div>
  </div>
</div>
<script>
(() => {
  const GRID_SIZE = 10;
  const SHAPE_POOL = [
    [[0,0]],
    [[0,0],[1,0]],
    [[0,0],[0,1]],
    [[0,0],[1,0],[2,0]],
    [[0,0],[0,1],[0,2]],
    [[0,0],[1,0],[0,1]],
    [[0,0],[1,0],[2,0],[3,0]],
    [[0,0],[0,1],[0,2],[0,3]],
    [[0,0],[1,0],[0,1],[1,1]],
    [[0,0],[1,0],[2,0],[1,1]],
    [[0,0],[0,1],[0,2],[1,2]],
    [[0,0],[1,0],[2,0],[2,1]],
    [[0,0],[1,0],[1,1],[2,1]],
    [[0,0],[0,1],[1,1],[2,1]]
  ];
  const COLORS = ["#00f7ff", "#ff7ad9", "#ff9f43", "#6bff8e", "#b388ff", "#ff4f74", "#5effa0", "#7a9cff", "#ffed4a", "#4ae3ff"];

  const startScreen = document.getElementById("start-screen");
  const gameScreen = document.getElementById("game-screen");
  const canvas = document.getElementById("game-canvas");
  const ctx = canvas.getContext("2d");
  const trayEl = document.getElementById("tray");
  const scoreEl = document.getElementById("score");
  const highScoreEl = document.getElementById("high-score");
  const timerEl = document.getElementById("timer");
  const comboPill = document.getElementById("combo-pill");
  const pauseOverlay = document.getElementById("pause-overlay");
  const gameoverOverlay = document.getElementById("gameover-overlay");
  const finalScoreEl = document.getElementById("final-score");
  const finalHighEl = document.getElementById("final-high");

  const soundBtn = document.getElementById("sound-btn");
  const toggleSoundBtn = document.getElementById("toggle-sound");
  const toggleMusicBtn = document.getElementById("toggle-music");

  const state = {
    grid: [],
    tray: [],
    dragging: null,
    pointer: { x: 0, y: 0 },
    cell: 0,
    offset: { x: 0, y: 0 },
    score: 0,
    combo: 1,
    highScores: { endless: 0, clock: 0 },
    mode: "endless",
    timeLeft: 0,
    timerActive: false,
    lastTime: 0,
    paused: false,
    gameOver: false,
    popups: [],
    clearAnimations: [],
    soundOn: true,
    musicOn: true,
    musicStarted: false
  };

  const sounds = {
    place: new Audio("placed.mp3"),
    clear: new Audio("rowmade.wav"),
    combo: new Audio("rowmade.wav"),
    over: new Audio("rowmade.wav"),
    bg: new Audio("bg.mp3")
  };
  sounds.bg.loop = true;
  sounds.bg.volume = 0.35;

  function updateSoundButtons() {
    const label = state.soundOn ? "On" : "Off";
    soundBtn.textContent = `Sound: ${label}`;
    toggleSoundBtn.textContent = `Sound: ${label}`;
    const mLabel = state.musicOn ? "On" : "Off";
    toggleMusicBtn.textContent = `Music: ${mLabel}`;
  }

  function vibrate(pattern) {
    if (navigator.vibrate) navigator.vibrate(pattern);
  }

  function playSound(key) {
    if (!state.soundOn) return;
    const audio = sounds[key];
    if (!audio) return;
    audio.currentTime = 0;
    audio.play().catch(() => {});
  }

  function ensureMusic() {
    if (!state.musicOn) {
      sounds.bg.pause();
      return;
    }
    if (!state.musicStarted) {
      sounds.bg.play().catch(() => {});
      state.musicStarted = true;
    } else if (sounds.bg.paused) {
      sounds.bg.play().catch(() => {});
    }
  }

  function setScreen(activeScreen) {
    [startScreen, gameScreen].forEach(screen => screen.classList.remove("active"));
    activeScreen.classList.add("active");
  }

  function resizeCanvas() {
    const wrap = document.getElementById("canvas-wrap");
    const rect = wrap.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    const ratio = window.devicePixelRatio || 1;
    canvas.width = size * ratio;
    canvas.height = size * ratio;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    state.cell = size / GRID_SIZE;
  }

  function initGrid() {
    state.grid = Array.from({ length: GRID_SIZE }, () => Array.from({ length: GRID_SIZE }, () => null));
  }

  function randomShape() {
    const shape = SHAPE_POOL[Math.floor(Math.random() * SHAPE_POOL.length)];
    return {
      cells: shape.map(([x,y]) => ({ x, y })),
      color: COLORS[Math.floor(Math.random() * COLORS.length)],
      used: false
    };
  }

  function fillTray() {
    state.tray = [randomShape(), randomShape(), randomShape()];
    renderTray();
  }

  function renderTray() {
    trayEl.innerHTML = "";
    state.tray.forEach((shape, idx) => {
      const item = document.createElement("div");
      item.className = "tray-item";
      item.dataset.index = idx;
      const mini = document.createElement("canvas");
      mini.width = 120; mini.height = 120;
      item.appendChild(mini);
      drawMini(mini.getContext("2d"), shape);
      trayEl.appendChild(item);
    });
  }

  function drawMini(mctx, shape) {
    if (!shape) return;
    const size = 20;
    const padding = 10;
    mctx.clearRect(0,0,120,120);
    mctx.save();
    mctx.translate(padding, padding);
    shape.cells.forEach(cell => {
      mctx.fillStyle = shape.color;
      mctx.shadowColor = shape.color;
      mctx.shadowBlur = 10;
      mctx.fillRect(cell.x * size, cell.y * size, size - 2, size - 2);
    });
    mctx.restore();
  }

  function resetGame(mode, time) {
    state.mode = mode;
    state.timeLeft = time || 0;
    state.timerActive = mode === "clock";
    state.score = 0;
    state.combo = 1;
    state.gameOver = false;
    state.paused = false;
    state.popups = [];
    state.clearAnimations = [];
    initGrid();
    fillTray();
    updateHUD();
    resizeCanvas();
    gameoverOverlay.classList.remove("active");
    pauseOverlay.classList.remove("active");
    ensureMusic();
  }

  function updateHUD() {
    scoreEl.textContent = state.score;
    const key = state.mode === "clock" ? "clock" : "endless";
    highScoreEl.textContent = state.highScores[key] || 0;
    if (state.timerActive) {
      const mins = Math.floor(state.timeLeft / 60).toString().padStart(2, "0");
      const secs = Math.floor(state.timeLeft % 60).toString().padStart(2, "0");
      timerEl.textContent = `${mins}:${secs}`;
    } else {
      timerEl.textContent = "--:--";
    }
    comboPill.textContent = `Combo x${state.combo}`;
  }

  function canPlace(shape, gridX, gridY) {
    return shape.cells.every(cell => {
      const x = gridX + cell.x;
      const y = gridY + cell.y;
      return x >= 0 && y >= 0 && x < GRID_SIZE && y < GRID_SIZE && !state.grid[y][x];
    });
  }

  function anyMovesAvailable() {
    return state.tray.some(shape => {
      if (!shape) return false;
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (canPlace(shape, x, y)) return true;
        }
      }
      return false;
    });
  }

  function placeShape(shape, gridX, gridY) {
    shape.cells.forEach(cell => {
      const x = gridX + cell.x;
      const y = gridY + cell.y;
      state.grid[y][x] = { color: shape.color, clearing: false };
    });
    state.score += shape.cells.length * 10;
    playSound("place");
    vibrate(10);
    const cleared = checkLines();
    if (cleared > 0) {
      const bonus = cleared * 100 * state.combo;
      state.score += bonus;
      addPopup(`+${bonus}`, gridX, gridY, shape.color);
      playSound(state.combo > 1 ? "combo" : "clear");
      state.combo += 1;
    } else {
      state.combo = 1;
    }
    updateHighScore();
    updateHUD();
  }

  function checkLines() {
    const fullRows = [];
    const fullCols = [];
    for (let y = 0; y < GRID_SIZE; y++) {
      if (state.grid[y].every(cell => cell && !cell.clearing)) fullRows.push(y);
    }
    for (let x = 0; x < GRID_SIZE; x++) {
      let full = true;
      for (let y = 0; y < GRID_SIZE; y++) {
        if (!state.grid[y][x] || state.grid[y][x].clearing) { full = false; break; }
      }
      if (full) fullCols.push(x);
    }
    if (fullRows.length || fullCols.length) {
      const now = performance.now();
      fullRows.forEach(y => {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (state.grid[y][x]) state.grid[y][x].clearing = now;
        }
      });
      fullCols.forEach(x => {
        for (let y = 0; y < GRID_SIZE; y++) {
          if (state.grid[y][x]) state.grid[y][x].clearing = now;
        }
      });
      state.clearAnimations.push({ rows: fullRows, cols: fullCols, start: now });
      return fullRows.length + fullCols.length;
    }
    return 0;
  }

  function updateClears() {
    const now = performance.now();
    const duration = 260;
    state.clearAnimations = state.clearAnimations.filter(anim => {
      if (now - anim.start > duration) {
        anim.rows.forEach(y => {
          for (let x = 0; x < GRID_SIZE; x++) state.grid[y][x] = null;
        });
        anim.cols.forEach(x => {
          for (let y = 0; y < GRID_SIZE; y++) state.grid[y][x] = null;
        });
        return false;
      }
      return true;
    });
  }

  function addPopup(text, gridX, gridY, color) {
    const x = (gridX + 0.5) * state.cell;
    const y = (gridY + 0.5) * state.cell;
    state.popups.push({ text, x, y, color, start: performance.now() });
  }

  function updatePopups() {
    const now = performance.now();
    state.popups = state.popups.filter(p => now - p.start < 900);
  }

  function updateHighScore() {
    const key = state.mode === "clock" ? "clock" : "endless";
    if (state.score > (state.highScores[key] || 0)) {
      state.highScores[key] = state.score;
      localStorage.setItem(`neon-block-${key}`, state.score.toString());
    }
  }

  function loadHighScores() {
    state.highScores.endless = parseInt(localStorage.getItem("neon-block-endless") || "0", 10);
    state.highScores.clock = parseInt(localStorage.getItem("neon-block-clock") || "0", 10);
  }

  function drawGrid() {
    const size = state.cell;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        const cell = state.grid[y][x];
        const px = x * size;
        const py = y * size;
        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.lineWidth = 1;
        ctx.strokeRect(px + 1, py + 1, size - 2, size - 2);
        if (cell) {
          const fade = cell.clearing ? Math.max(0, 1 - (performance.now() - cell.clearing) / 260) : 1;
          ctx.fillStyle = cell.color;
          ctx.globalAlpha = fade;
          ctx.shadowColor = cell.color;
          ctx.shadowBlur = 16;
          ctx.fillRect(px + 4, py + 4, size - 8, size - 8);
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
        }
      }
    }
    if (state.dragging && state.dragging.valid && !state.paused) {
      ctx.save();
      ctx.globalAlpha = 0.4;
      state.dragging.shape.cells.forEach(cell => {
        const gx = state.dragging.gridX + cell.x;
        const gy = state.dragging.gridY + cell.y;
        if (gx < 0 || gy < 0 || gx >= GRID_SIZE || gy >= GRID_SIZE) return;
        ctx.fillStyle = state.dragging.shape.color;
        ctx.fillRect(gx * size + 4, gy * size + 4, size - 8, size - 8);
      });
      ctx.restore();
    }
    state.popups.forEach(popup => {
      const age = performance.now() - popup.start;
      const t = age / 900;
      const rise = 20 * t;
      ctx.globalAlpha = 1 - t;
      ctx.fillStyle = popup.color;
      ctx.font = "bold 20px Segoe UI";
      ctx.fillText(popup.text, popup.x, popup.y - rise);
      ctx.globalAlpha = 1;
    });
    ctx.restore();
  }

  function drawDragging() {
    if (!state.dragging) return;
    const { shape } = state.dragging;
    const size = state.cell;
    shape.cells.forEach(cell => {
      const x = state.pointer.x + (cell.x * size) - state.offset.x;
      const y = state.pointer.y + (cell.y * size) - state.offset.y;
      ctx.fillStyle = shape.color;
      ctx.shadowColor = shape.color;
      ctx.shadowBlur = 16;
      ctx.fillRect(x + 4, y + 4, size - 8, size - 8);
      ctx.shadowBlur = 0;
    });
  }

  function updateTimer(delta) {
    if (!state.timerActive || state.paused || state.gameOver) return;
    state.timeLeft = Math.max(0, state.timeLeft - delta / 1000);
    if (state.timeLeft === 0) {
      triggerGameOver();
    }
  }

  function triggerGameOver() {
    state.gameOver = true;
    pauseOverlay.classList.remove("active");
    gameoverOverlay.classList.add("active");
    finalScoreEl.textContent = `Score: ${state.score}`;
    const key = state.mode === "clock" ? "clock" : "endless";
    finalHighEl.textContent = `High Score: ${state.highScores[key] || 0}`;
    playSound("over");
    vibrate([60, 40, 80]);
  }

  function handlePointerDown(event) {
    if (state.paused || state.gameOver) return;
    const target = event.target.closest(".tray-item");
    if (!target) return;
    const index = parseInt(target.dataset.index, 10);
    const shape = state.tray[index];
    if (!shape) return;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    state.dragging = { shape, index, gridX: 0, gridY: 0, valid: false };
    state.pointer = { x, y };
    state.offset = { x: state.cell / 2, y: state.cell / 2 };
  }

  function handlePointerMove(event) {
    if (!state.dragging) return;
    const rect = canvas.getBoundingClientRect();
    state.pointer.x = event.clientX - rect.left;
    state.pointer.y = event.clientY - rect.top;
    const gridX = Math.floor((state.pointer.x - state.offset.x) / state.cell + 0.5);
    const gridY = Math.floor((state.pointer.y - state.offset.y) / state.cell + 0.5);
    state.dragging.gridX = gridX;
    state.dragging.gridY = gridY;
    state.dragging.valid = canPlace(state.dragging.shape, gridX, gridY);
  }

  function handlePointerUp() {
    if (!state.dragging) return;
    if (state.dragging.valid) {
      placeShape(state.dragging.shape, state.dragging.gridX, state.dragging.gridY);
      state.tray[state.dragging.index] = null;
      if (state.tray.every(item => !item)) {
        fillTray();
      } else {
        renderTray();
      }
      if (!anyMovesAvailable()) {
        triggerGameOver();
      }
    }
    state.dragging = null;
  }

  function gameLoop(ts) {
    if (!state.lastTime) state.lastTime = ts;
    const delta = ts - state.lastTime;
    state.lastTime = ts;
    if (!state.paused && !state.gameOver) {
      updateTimer(delta);
      updateClears();
      updatePopups();
    }
    updateHUD();
    drawGrid();
    if (state.dragging && !state.paused) drawDragging();
    requestAnimationFrame(gameLoop);
  }

  function bindEvents() {
    document.querySelectorAll("[data-mode]").forEach(btn => {
      btn.addEventListener("click", () => {
        const mode = btn.dataset.mode;
        const time = parseInt(btn.dataset.time || "0", 10);
        resetGame(mode, time);
        setScreen(gameScreen);
      });
    });
    document.getElementById("pause-btn").addEventListener("click", () => {
      state.paused = true;
      pauseOverlay.classList.add("active");
    });
    document.getElementById("resume-btn").addEventListener("click", () => {
      state.paused = false;
      pauseOverlay.classList.remove("active");
    });
    document.getElementById("restart-btn").addEventListener("click", () => {
      resetGame(state.mode, state.timerActive ? Math.round(state.timeLeft) : 0);
    });
    document.getElementById("exit-btn").addEventListener("click", () => {
      setScreen(startScreen);
    });
    document.getElementById("play-again").addEventListener("click", () => {
      resetGame(state.mode, state.timerActive ? Math.round(state.timeLeft) : 0);
    });
    document.getElementById("back-menu").addEventListener("click", () => {
      setScreen(startScreen);
    });

    soundBtn.addEventListener("click", () => {
      state.soundOn = !state.soundOn;
      updateSoundButtons();
    });
    toggleSoundBtn.addEventListener("click", () => {
      state.soundOn = !state.soundOn;
      updateSoundButtons();
    });
    toggleMusicBtn.addEventListener("click", () => {
      state.musicOn = !state.musicOn;
      if (!state.musicOn) sounds.bg.pause();
      updateSoundButtons();
    });

    trayEl.addEventListener("pointerdown", handlePointerDown);
    window.addEventListener("pointermove", handlePointerMove);
    window.addEventListener("pointerup", handlePointerUp);
    window.addEventListener("resize", resizeCanvas);

    document.addEventListener("visibilitychange", () => {
      if (document.hidden && !state.gameOver) {
        state.paused = true;
        pauseOverlay.classList.add("active");
      }
    });
  }

  loadHighScores();
  updateSoundButtons();
  bindEvents();
  resizeCanvas();
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
